'''
1. Используя псевдокод процедуры Randomized - QuickSort, а так же Partition
из презентации к Лекции 3 (страницы 8 и 12), напишите программу быстрой
сортировки на Python и проверьте ее, создав несколько рандомных массивов,
подходящих под параметры:
• Формат входного файла (input.txt). В первой строке входного файла
содержится число n (1 ≤ n ≤ 104) — число элементов в массиве.
Во второй строке находятся n различных целых чисел, по модулю не
превосходящих 109.
• Формат выходного файла (output.txt). Одна строка выходного файла
с отсортированным массивом. Между любыми двумя числами должен
стоять ровно один пробел.
• Ограничение по времени. 2 сек.
• Ограничение по памяти. 256 мб.
• Для проверки можно выбрать наихудший случай, когда сортируется
массив рамера 103, 104, 105 чисел порядка 109, отсортированных в об-
ратном порядке; наилучший, когда массив уже отсортирван, и средний
- случайный. Сравните на данных сетах Randomized-QuickSort и про-
стой QuickSort. (А также есть Median-QuickSort, см. задание 10.2;
и Tail-Recursive-QuickSort, см. Кормен. 2013, стр. 217)

2. Основное задание. Цель задачи - переделать данную реализацию рандо-
мизированного алгоритма быстрой сортировки, чтобы она работала быстро
даже с последовательностями, содержащими много одинаковых элементов.
Чтобы заставить алгоритм быстрой сортировки эффективно обрабатывать
последовательности с несколькими уникальными элементами, нужно заме-
нить двухстороннее разделение на трехстороннее (смотри в Лекции 3 слайд
17). То есть ваша новая процедура разделения должна разбить массив на три
части:
• A[k] < x для всех l + 1 ≤ k ≤ m1 − 1
• A[k] = x для всех m1 ≤ k ≤ m2
• A[k] > x для всех m2 + 1 ≤ k ≤ r
• Формат входного и выходного файла аналогичен п.1.
• Аналогично п.1 этого задания сравните Randomized-QuickSort +c
Partition и ее с Partition3 на сетах случайных данных, в которых
содержатся всего несколько уникальных элементов при n = 103, 104, 105.
Что быстрее, Randomized-QuickSort +c Partition3 или Merge-Sort?
'''

import time
 
t_start = time.perf_counter()

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1

    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1

def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)

with open('task1.txt', 'r') as file:
    n = int(file.readline())
    array = list(map(int, file.readline().split()))

quick_sort(array, 0, n - 1)

with open('output.txt', 'w') as file:
    file.write(' '.join(map(str, array)))

print("Время работы: %s секунд " % (time.perf_counter() - t_start))